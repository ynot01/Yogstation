<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <base href="../../" />
    <link rel="stylesheet" href="dmdoc.css" />
    <title>code&#x2F;__DEFINES&#x2F;rust_g.dm - Yogstation 13</title>
</head>
<body>
<header>
    <a href="index.html">Yogstation 13</a> -
    <a href="index.html#modules">Modules</a> -
    <a href="index.html#types">Types</a>
 &mdash; <a href="code/__DEFINES/rust_g.html#define">Define Details</a></header>
<main>
<h1>code/__DEFINES/rust_g.dm 
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm"/></a></h1>

<table class="summary" cellspacing="0">
        <tr><th>/proc/<a href="global.html#proc/rustg_get_version">rustg_get_version</a></th>
                <td>Gets the version of rust_g</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_setup_acreplace">rustg_setup_acreplace</a></th><td>Sets up the Aho-Corasick automaton with its default options.</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_setup_acreplace_with_options">rustg_setup_acreplace_with_options</a></th><td>Sets up the Aho-Corasick automaton using supplied options.</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_acreplace">rustg_acreplace</a></th><td>Run the specified replacement engine with the provided haystack text to replace, returning replaced text.</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_acreplace_with_replacements">rustg_acreplace_with_replacements</a></th><td>Run the specified replacement engine with the provided haystack text to replace, returning replaced text.</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_bsp_generate">rustg_bsp_generate</a></th><td>This proc generates rooms in a specified area of random size and placement. Essential for procedurally generated areas, BSP works by cutting a given area in half,
then cutting one of those subsections in half, and repeating this process until a minimum size is reached, then backtracking to other subsections that are not of
the minimum size yet. These cuts are offset by small random amounts so that the sections are all varied in size and shape.</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_cnoise_generate">rustg_cnoise_generate</a></th><td>This proc generates a cellular automata noise grid which can be used in procedural generation methods.</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_dbp_generate">rustg_dbp_generate</a></th><td>This proc generates a grid of perlin-like noise</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_register_nodes_astar">rustg_register_nodes_astar</a></th><td>Register a list of nodes into a rust library. This list of nodes must have been serialized in a json.
Node {// Index of this node in the list of nodes
unique_id: usize,
// Position of the node in byond
x: usize,
y: usize,
z: usize,
// Indexes of nodes connected to this one
connected_nodes_id: Vec<usize>}
It is important that the node with the unique_id 0 is the first in the json, unique_id 1 right after that, etc.
It is also important that all unique ids follow. {0, 1, 2, 4} is not a correct list and the registering will fail
Nodes should not link across z levels.
A node cannot link twice to the same node and shouldn't link itself either</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_add_node_astar">rustg_add_node_astar</a></th><td>Add a new node to the static list of nodes. Same rule as registering_nodes applies.
This node unique_id must be equal to the current length of the static list of nodes</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_remove_node_astart">rustg_remove_node_astart</a></th><td>*Â²</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_generate_path_astar">rustg_generate_path_astar</a></th><td>Compute the shortest path between start_node and goal_node using A*. Heuristic used is simple geometric distance</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_random_room_generate">rustg_random_room_generate</a></th><td>This proc generates rooms in a specified area of random size and placement. Used in procedural generation, but far less intensively than Binary Space Partitioning
due to Random Room Placement being far more simple and unreliable for area coverage. These rooms will not overlap one another, but that is the only logic
they do. The room dimensions returned by this call are hardcoded to be the dimensions of maint ruins so that I could sprinkle pre-generated areas over
the binary space rooms that are random.
These dimensions are:</td></tr>
        <tr><th><a href="code/__DEFINES/rust_g.html#define/rustg_worley_generate">rustg_worley_generate</a></th><td>This proc generates a noise grid using worley noise algorithm</td></tr></table><h2 id="define">Define Details</h2>
<h3 id="define/rustg_acreplace"><aside class="declaration">#define </aside>rustg_acreplace
            <aside>(key, text)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L82">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 82"/></a>
    </h3>
    <p>Run the specified replacement engine with the provided haystack text to replace, returning replaced text.</p>
<p>Arguments:</p>
<ul>
<li>key - The key for the automaton</li>
<li>text - Text to run replacements on</li>
</ul><h3 id="define/rustg_acreplace_with_replacements"><aside class="declaration">#define </aside>rustg_acreplace_with_replacements
            <aside>(key, text, replacements)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L92">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 92"/></a>
    </h3>
    <p>Run the specified replacement engine with the provided haystack text to replace, returning replaced text.</p>
<p>Arguments:</p>
<ul>
<li>key - The key for the automaton</li>
<li>text - Text to run replacements on</li>
<li>replacements - Replacements for this call. Must be the same length as the set-up patterns</li>
</ul><h3 id="define/rustg_add_node_astar"><aside class="declaration">#define </aside>rustg_add_node_astar
            <aside>(json)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L232">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 232"/></a>
    </h3>
    <p>Add a new node to the static list of nodes. Same rule as registering_nodes applies.
This node unique_id must be equal to the current length of the static list of nodes</p><h3 id="define/rustg_bsp_generate"><aside class="declaration">#define </aside>rustg_bsp_generate
            <aside>(width, height, hash, map_subsection_min_size, map_subsection_min_room_width, map_subsection_min_room_height)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L116">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 116"/></a>
    </h3>
    <p>This proc generates rooms in a specified area of random size and placement. Essential for procedurally generated areas, BSP works by cutting a given area in half,
then cutting one of those subsections in half, and repeating this process until a minimum size is reached, then backtracking to other subsections that are not of
the minimum size yet. These cuts are offset by small random amounts so that the sections are all varied in size and shape.</p>
<p>BSP excels at creating rooms or areas with a relatively even distribution over an area, so there won't be too much blank open area. However if you discard rooms that
overlap pre-existing map structures or areas, you may still get blank areas where nothing interesting appears.</p>
<p>Return:</p>
<ul>
<li>a json list of room data to be processed by json_decode in byond and further processed there.</li>
</ul>
<p>Arguments:</p>
<ul>
<li>width: the width of the area to generate in</li>
<li>height: the height of the area to generate in</li>
<li>hash: the rng seed the generator will use for this instance</li>
<li>map_subsection_min_size: The minimum size of a map subsection. When using this for rooms with walls, the minimum possible square will be a 5x5 room. Barring walls,
this will be a 3x3 room. The maximum size will be 9x9, because a further cut could reduce this size beneath the minimum size.</li>
<li>map_subsection_min_room_width: The minimum room width once the subsections are finalized. Room width and height are random between this amount, and the subsection
max size</li>
<li>map_subsection_min_room_height: The minimum room height once the subsections are finalized. Room width and height are random between this amount, and the subsection
max size</li>
</ul><h3 id="define/rustg_cnoise_generate"><aside class="declaration">#define </aside>rustg_cnoise_generate
            <aside>(percentage, smoothing_iterations, birth_limit, death_limit, width, height)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L132">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 132"/></a>
    </h3>
    <p>This proc generates a cellular automata noise grid which can be used in procedural generation methods.</p>
<p>Returns a single string that goes row by row, with values of 1 representing an alive cell, and a value of 0 representing a dead cell.</p>
<p>Arguments:</p>
<ul>
<li>percentage: The chance of a turf starting closed</li>
<li>smoothing_iterations: The amount of iterations the cellular automata simulates before returning the results</li>
<li>birth_limit: If the number of neighboring cells is higher than this amount, a cell is born</li>
<li>death_limit: If the number of neighboring cells is lower than this amount, a cell dies</li>
<li>width: The width of the grid.</li>
<li>height: The height of the grid.</li>
</ul><h3 id="define/rustg_dbp_generate"><aside class="declaration">#define </aside>rustg_dbp_generate
            <aside>(seed, accuracy, stamp_size, world_size, lower_range, upper_range)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L148">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 148"/></a>
    </h3>
    <p>This proc generates a grid of perlin-like noise</p>
<p>Returns a single string that goes row by row, with values of 1 representing an turned on cell, and a value of 0 representing a turned off cell.</p>
<p>Arguments:</p>
<ul>
<li>seed: seed for the function</li>
<li>accuracy: how close this is to the original perlin noise, as accuracy approaches infinity, the noise becomes more and more perlin-like</li>
<li>stamp_size: Size of a singular stamp used by the algorithm, think of this as the same stuff as frequency in perlin noise</li>
<li>world_size: size of the returned grid.</li>
<li>lower_range: lower bound of values selected for. (inclusive)</li>
<li>upper_range: upper bound of values selected for. (exclusive)</li>
</ul><h3 id="define/rustg_generate_path_astar"><aside class="declaration">#define </aside>rustg_generate_path_astar
            <aside>(start_node_id, goal_node_id)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L242">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 242"/></a>
    </h3>
    <p>Compute the shortest path between start_node and goal_node using A*. Heuristic used is simple geometric distance</p><h3 id="define/rustg_random_room_generate"><aside class="declaration">#define </aside>rustg_random_room_generate
            <aside>(width, height, desired_room_count, hash)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L266">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 266"/></a>
    </h3>
    <p>This proc generates rooms in a specified area of random size and placement. Used in procedural generation, but far less intensively than Binary Space Partitioning
due to Random Room Placement being far more simple and unreliable for area coverage. These rooms will not overlap one another, but that is the only logic
they do. The room dimensions returned by this call are hardcoded to be the dimensions of maint ruins so that I could sprinkle pre-generated areas over
the binary space rooms that are random.
These dimensions are:</p>
<ul>
<li>3x3</li>
<li>3x5</li>
<li>5x3</li>
<li>5x4</li>
<li>10x5</li>
<li>10x10</li>
</ul>
<p>Return:</p>
<ul>
<li>a json list of room data to be processed by json_decode in byond and further processed there.</li>
</ul>
<p>Arguments:</p>
<ul>
<li>width: the width of the area to generate in</li>
<li>height: the height of the area to generate in</li>
<li>desired_room_count: the number of rooms you want generated and returned</li>
<li>hash: the rng seed the generator will use for this instance</li>
</ul><h3 id="define/rustg_register_nodes_astar"><aside class="declaration">#define </aside>rustg_register_nodes_astar
            <aside>(json)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L226">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 226"/></a>
    </h3>
    <p>Register a list of nodes into a rust library. This list of nodes must have been serialized in a json.
Node {// Index of this node in the list of nodes
unique_id: usize,
// Position of the node in byond
x: usize,
y: usize,
z: usize,
// Indexes of nodes connected to this one
connected_nodes_id: Vec<usize>}
It is important that the node with the unique_id 0 is the first in the json, unique_id 1 right after that, etc.
It is also important that all unique ids follow. {0, 1, 2, 4} is not a correct list and the registering will fail
Nodes should not link across z levels.
A node cannot link twice to the same node and shouldn't link itself either</p><h3 id="define/rustg_remove_node_astart"><aside class="declaration">#define </aside>rustg_remove_node_astart
            <aside>(unique_id)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L237">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 237"/></a>
    </h3>
    <p>*Â²</p>
<ul>
<li>Remove every link to the node with unique_id. Replace that node by null</li>
</ul><h3 id="define/rustg_setup_acreplace"><aside class="declaration">#define </aside>rustg_setup_acreplace
            <aside>(key, patterns, replacements)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L61">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 61"/></a>
    </h3>
    <p>Sets up the Aho-Corasick automaton with its default options.</p>
<p>The search patterns list and the replacements must be of the same length when replace is run, but an empty replacements list is allowed if replacements are supplied with the replace call
Arguments:</p>
<ul>
<li>key - The key for the automaton, to be used with subsequent rustg_acreplace/rustg_acreplace_with_replacements calls</li>
<li>patterns - A non-associative list of strings to search for</li>
<li>replacements - Default replacements for this automaton, used with rustg_acreplace</li>
</ul><h3 id="define/rustg_setup_acreplace_with_options"><aside class="declaration">#define </aside>rustg_setup_acreplace_with_options
            <aside>(key, options, patterns, replacements)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L73">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 73"/></a>
    </h3>
    <p>Sets up the Aho-Corasick automaton using supplied options.</p>
<p>The search patterns list and the replacements must be of the same length when replace is run, but an empty replacements list is allowed if replacements are supplied with the replace call
Arguments:</p>
<ul>
<li>key - The key for the automaton, to be used with subsequent rustg_acreplace/rustg_acreplace_with_replacements calls</li>
<li>options - An associative list like list(&quot;anchored&quot; = 0, &quot;ascii_case_insensitive&quot; = 0, &quot;match_kind&quot; = &quot;Standard&quot;). The values shown on the example are the defaults, and default values may be omitted. See the identically named methods at https://docs.rs/aho-corasick/latest/aho_corasick/struct.AhoCorasickBuilder.html to see what the options do.</li>
<li>patterns - A non-associative list of strings to search for</li>
<li>replacements - Default replacements for this automaton, used with rustg_acreplace</li>
</ul><h3 id="define/rustg_worley_generate"><aside class="declaration">#define </aside>rustg_worley_generate
            <aside>(region_size, threshold, node_per_region_chance, size, node_min, node_max)</aside>
            <a href="https://github.com/ynot01/Yogstation/blob/51b5eda3afef033ca1a66b26e17ab2278c21bb39/code/__DEFINES/rust_g.dm#L336">
        <img src="git.png" width="16" height="16" title="code&#x2F;__DEFINES&#x2F;rust_g.dm 336"/></a>
    </h3>
    <p>This proc generates a noise grid using worley noise algorithm</p>
<p>Returns a single string that goes row by row, with values of 1 representing an alive cell, and a value of 0 representing a dead cell.</p>
<p>Arguments:</p>
<ul>
<li>region_size: The size of regions</li>
<li>threshold: the value that determines wether a cell is dead or alive</li>
<li>node_per_region_chance: chance of a node existiing in a region</li>
<li>size: size of the returned grid</li>
<li>node_min: minimum amount of nodes in a region (after the node_per_region_chance is applied)</li>
<li>node_max: maximum amount of nodes in a region</li>
</ul></main>
<footer>
    yogstation.dme
    <a href="https://github.com/ynot01/Yogstation/tree/51b5eda3afef033ca1a66b26e17ab2278c21bb39">51b5eda</a>
        (master) &mdash; <a href="https://github.com/SpaceManiac/SpacemanDMM/blob/master/crates/dmdoc/README.md">dmdoc 1.8.0</a></footer>
</body>
</html>
